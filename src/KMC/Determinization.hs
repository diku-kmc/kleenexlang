{-# LANGUAGE TypeFamilies #-}
{-# LANGUAGE FlexibleContexts #-}
module KMC.Determinization where

import           Control.Monad.State
import           Data.Maybe (maybeToList, isJust)
import qualified Data.Set as S
import           KMC.SymbolicFST
import           KMC.SymbolicSST
import           KMC.Theories
import           KMC.TreeWriter
import           KMC.Util.List (lcpMany1, linv')

-- | The functions in the symbolic transitions generated by the path tree
-- determinization procedure are obtained by extending the functions in the
-- determinized FST. Namely, by adjoining an epsilon element to the set of
-- functions and extending functions to sequences.
type SSTFunc f = [EpsFunc f]

-- | A variable is identified by its position in the path tree. The position is
-- represented as a sequence of integers representing the path from the root of
-- the path tree to a given node.
data Var = Var [Int]
  deriving (Eq, Ord, Show)

instance PartialOrder Var where
  lte (Var l) (Var r) = reverse l `prefixOf` reverse r
      where
        prefixOf [] _ = True
        prefixOf (x:xs) (y:ys) = (x==y) && prefixOf xs ys
        prefixOf _ _ = False


----------------
-- Closure monad
----------------

-- | The closure monad models a computation consisting of concurrent threads
-- with shared state executed in round-robin
type Closure st w = TreeWriterT w (State (S.Set st))
type PathTree w a = Maybe (Tree w a)

visit :: (Monoid w, Ord st) => st -> Closure st w st
visit st = do { vis <- get;
                when (S.member st vis) zero;
                modify (S.insert st);
                return st
              }

-- | Resume a closure computation
resume :: (Monoid w) => Tree w a -> Closure st w a
resume (Tip w x) = tell w >> return x
resume (Fork w ts) = tell w >> branch (map resume ts)

-- | Resume a possibly failing closure computation
resume' :: Monoid w => PathTree w a -> Closure st w a
resume' Nothing = zero
resume' (Just t) = resume t

-- | Reduce a tree by removing longest common prefixes
reduce :: (Eq a) => Tree [a] b -> Tree [a] b
reduce (Tip w b)   = Tip w b
reduce (Fork w ts) =
  Fork (w ++ p) $ [ t { tOutput = linv' p (tOutput t) } | t <- ts' ]
  where
    ts' = map reduce ts
    p   = lcpMany1 (map tOutput ts')

-- | Interpret a closure computation as a path tree and reduce the result.
runClosure :: (Eq gamma) => Closure st [gamma] a -> PathTree [gamma] a
runClosure x = reduce <$> evalState (runTreeWriterT x) S.empty


-----------------------
-- Computing path trees
-----------------------

genclosure :: (Ord st, Monoid w)
           => FST st pred func
           -> (Rng func -> w)
           -> st
           -> Closure st w st
genclosure fst' inj q =
  case fstEvalEpsilonEdges fst' q of
    [] -> return q
    qs -> branch $
            map (\(out, q') -> tell (inj out)
                               >> visit q'
                               >> genclosure fst' inj q') qs

-- | Non-deterministically follow all non-input transitions.
closure :: (Ord st)
           => FST st pred func
           -> st
           -> Closure st (UpdateString var (Rng func)) st
closure fst' q = genclosure fst' (\c -> [Right c]) q

closureFunc :: (Ord st) =>
               FST st pred func
            -> st
            -> Closure st (UpdateStringFunc var (SSTFunc func)) st
closureFunc fst' q = genclosure fst' (\c -> [ConstA c]) q

consume :: (PartialOrder pred, Ord st)
        => (func -> func') -> FST st pred func -> pred -> st -> Closure st (UpdateStringFunc var func') st
consume inj fst' p q =
  case fstAbstractEvalEdgesAll fst' q p of
    []        -> zero
    [(f, q')] -> tell [FuncA (inj f)] >> visit q'
    _ -> error "Stepping for FSTs with read-fanout greater than one is not supported yet"

eof :: (Monoid w, Ord st) => FST st pred func -> st -> Closure st w st
eof fst' q | S.member q (fstF fst') = visit q
           | otherwise = zero

kill :: (Ord st) => S.Set st -> st -> Closure st (UpdateStringFunc var func) st
kill kills q | S.member q kills = zero
             | otherwise = return q

closureAbstractTree :: (Eq var, Eq (Rng func), Ord a) =>
                       FST a pred func
                    -> PathTree var a
                    -> PathTree (UpdateString var (Rng func)) a
closureAbstractTree fst' tr =
  let tr' = fmap (mapOutput (return . Left)) tr
  in runClosure (resume' tr' >>= closure fst')

closureTree :: (Eq var, Eq (Rng func), Ord st) =>
               FST st pred func
            -> PathTree (UpdateString var (Rng func)) st
            -> PathTree (UpdateString var (Rng func)) st
closureTree fst' tr = runClosure (resume' tr >>= closure fst')

closureTreeFunc :: (Eq var, Eq func, Eq (Rng func), Ord st) =>
               FST st pred func
            -> PathTree (UpdateStringFunc var (SSTFunc func)) st
            -> PathTree (UpdateStringFunc var (SSTFunc func)) st
closureTreeFunc fst' tr = runClosure (resume' tr >>= closureFunc fst')

eofTree :: (Ord a, Eq gamma) => FST a pred func -> PathTree [gamma] a -> PathTree [gamma] a
eofTree fst' tr = runClosure (resume' tr >>= eof fst')

consumeTree :: (Eq func', Eq var, Eq (Rng func'), PartialOrder pred, Ord st)
            => (func -> func')
            -> FST st pred func
            -> pred
            -> PathTree (UpdateStringFunc var func') st
            -> PathTree (UpdateStringFunc var func') st
consumeTree inj fst' p tr = runClosure (resume' tr >>= consume inj fst' p)

killTree :: (Ord st, Eq var, Eq func, Eq (Rng func)) =>
            S.Set st -> PathTree (UpdateStringFunc var func) st
                     -> PathTree (UpdateStringFunc var func) st
killTree kills tr = runClosure (resume' tr >>= kill kills)


-------------------------
-- Abstracting path trees
-------------------------

abstract :: Tree (UpdateStringFunc Var func) a
            -> ([(Var, UpdateStringFunc Var func)], Tree Var a)
abstract t = go [] t
  where
  go v (Tip w a) = ([(Var v, w)], Tip (Var v) a)
  go v (Fork w ts) =
    let (ms, ts') = unzip [ go (m:v) t' | (m, t') <- zip [0..] ts ]
    in ((Var v, w):concat ms, Fork (Var v) ts')

abstract' :: PathTree (UpdateStringFunc Var func) a
            -> ([(Var, UpdateStringFunc Var func)], PathTree Var a)
abstract' Nothing = ([], Nothing)
abstract' (Just t) = let (m', t') = abstract t in (m', Just t')

unabstract :: PathTree (UpdateString var (Rng func)) a
           -> PathTree (UpdateStringFunc var func) a
unabstract = fmap (mapOutput (constUpdateStringFunc))


---------------------
-- SST specialization
---------------------

specialize :: (Function func, Dom func ~ [sigma], Rng func ~ [delta]
              ,Enumerable pred sigma
              ,Ord st) =>
              [(st, [pred], [(var, UpdateStringFunc var func)], st)]
              -> [(st, [pred], [(var, UpdateStringFunc var func)], st)]
specialize ts =
  [ (q, ps, [ (v, resolveConstFunc $ specFunc ps f) | (v,f) <- xs ], q')
    | (q, ps, xs, q') <- ts ]
  where
    resolveConstFunc = normalizeUpdateStringFunc . concatMap resolve
    resolve (FuncA f) | Just c <- isConst f = [ConstA c]
    resolve x = [x]

    specFunc ps f =
      if product (map size ps) == 1 then
          constUpdateStringFunc $ evalUpdateStringFunc (map (lookupIndex 0) ps) f
      else
          f


----------------------------
-- SST construction from FST
----------------------------

-- | Consume a number of abstract symbols (represented as a list of predicates)
-- and compute the resulting path tree.
consumeTreeMany :: (PartialOrder pred, Ord st, Eq var, Eq func, Eq (Rng func)) =>
                   FST st pred func
                -> [pred]
                -> PathTree (UpdateStringFunc var (SSTFunc func)) st
                -> PathTree (UpdateStringFunc var (SSTFunc func)) st
consumeTreeMany fst' preds = go 0 preds
    where
      -- SST functions have list ranges, whereas the underlying FST function is
      -- assumed to look at a single symbol at a time. `inj i f' is a function
      -- that calls f on the i'th symbol in the input list and leaves the rest
      -- alone.
      inj = let n = length preds
            in \i f -> replicate i EpsFunc ++ JustFunc f:replicate (n-i-1) EpsFunc

      go _ [] tr = tr
      go i (p:ps) tr = go (i+1) ps (closureTreeFunc fst' (consumeTree (inj i) fst' p (closureTreeFunc fst' tr)))

-- | Determinize the path tree simulation algorithm for some FST
sstFromFST
  :: (Bounded (Dom func), Enum (Dom func), Eq func, Eq delta,
      Eq (Rng func), Ord st, Ord pred, Monoid (Rng func),
      PartialOrder pred, Function func, Enumerable pred (Dom func),
      Boolean pred, Rng func ~ [delta]) =>
     FST st pred func
     -> Bool -> SST (PathTree Var st) pred (SSTFunc func) Var
sstFromFST fst' singletonMode =
  construct initialState (specialize transitions) outputs
  where
    initialState           = Just (Tip (Var []) (fstI fst'))
    (transitions, outputs) = saturate (S.singleton initialState) S.empty [] []

    saturate ws states trans outs
      | S.null ws                      = (trans, outs)
      | (t, ws') <- S.deleteFindMin ws, S.member t states
                                       = saturate ws' states trans outs
      | (t, ws') <- S.deleteFindMin ws =
        let tcl  = closureAbstractTree fst' t
            tcl' = unabstract tcl
            os   = [ (t, w) | Tip w _ <- maybeToList $ eofTree fst' tcl ]
            ts   = do (ps, kills) <- prefixTests fst' singletonMode (concatMap tflat $ maybeToList tcl')
                      guard $ not $ null ps
                      let (kappa, t'') = abstract' $ consumeTreeMany fst' ps $ killTree kills tcl'
                      guard (isJust t'')
                      return (t, ps, kappa, t'')
            wl'  = S.fromList [ newt | (_,_,_,newt) <- ts ]
        in saturate (S.union ws' wl') (S.insert t states) (ts ++ trans) (os ++ outs)
